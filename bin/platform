#!/usr/bin/env python
#
# Allow the user to configure and switch between various different
# "platforms" in which to build and run programs.  A platform is a
# storage location for build artifacts.  Each platform can be
# configured to point to parent platforms--environment variables like
# LD_LIBRARY_PATH are set to point to the build artifacts from the
# parent platforms.
#
# Storage model:
#
# - $HOME/.platform
#   - $PLATFORM_NAME
#     - install
#       - include: headers produced by this platform
#       - lib: libraries produced by this platform
#         - dri: libgl drivers produced by this platform
#         - pkgconfig: package configs produced by this platform
#       - bin: binaries produced by this platform
#       - share
#         - pkgconfig: package configs produced by this platform
#
# Shell variables modified when a platform is active:
# - $PLATFORM_NAME (e.g. "mesa")
# - $PLATFORM_ROOT_DIR (e.g. "~/.platform/mesa")
# - $PLATFORM_INSTALL_DIR (e.g. "~/.platform/mesa/install")
# - $PLATFORM_DESC (e.g. "mesa()")
# - $CPATH ("include" subdir prepended)
# - $LD_LIBRARY_PATH ("lib" subdir prepended)
# - $LIBGL_DRIVERS_PATH ("lib/dri" subdir prepended)
# - $LIBRARY_PATH ("lib" subdir prepended)
# - $PATH ("bin" subdir prepended)
# - $PKG_CONFIG_PATH ("pkgconfig" subdirs prepended)

import os.path
import sys
import subprocess

def usage():
    exec_short_name = os.path.basename(sys.argv[0])
    print """Usage:
  {0} info <platform>: summarize platform
  {0} use <platform>: start subshell with platform active
  {0} using <platform> <cmd>: run cmd with platform active
  {0} list: list all platforms
  {0} checkactive: succeed if a platform is active
  {0} binst <platform>: build and install platform (defaults to current)
""".format(exec_short_name)
    exit(1)

def fix_path(env):
    # Because Python's exec functions don't understand ~ in PATH
    if 'PATH' in env:
        env['PATH'] = os.pathsep.join(os.path.expanduser(p) for p in env['PATH'].split(os.pathsep))

def runcmds(cmds, env):
    fix_path(env)
    try:
        for cmd in cmds:
            result = subprocess.check_call(cmd, close_fds=True, env=env)
    except subprocess.CalledProcessError, e:
        exit(e.returncode)

class Platform(object):
    def __init__(self, name, parents, binstcmds = None):
        self.__name = name
        self.__parents = parents
        self.__binstcmds = binstcmds

    @property
    def parents(self):
        return self.__parents

    @property
    def desc(self):
        return '{0}({1})'.format(self.__name, ' '.join(self.__parents))

    def setup_env(self):
        def prepend(envname, newpath):
            if envname in env:
                env[envname] = os.pathsep.join([newpath, env[envname]])
            else:
                env[envname] = newpath

        env = dict(os.environ)
        fix_path(env)
        env['PLATFORM_NAME'] = self.__name
        root = os.path.join(os.path.expanduser('~'), '.platform', self.__name)
        try:
            os.makedirs(root)
        except OSError:
            # Assume already existed
            pass
        env['PLATFORM_ROOT_DIR'] = root
        env['PLATFORM_DESC'] = self.desc
        env['PLATFORM_INSTALL_DIR'] = os.path.join(root, 'install')
        for parent in self.__parents:
            install_dir = os.path.join(os.path.expanduser('~'), '.platform', parent, 'install')
            prepend('CPATH', os.path.join(install_dir, 'include'))
            prepend('LD_LIBRARY_PATH', os.path.join(install_dir, 'lib'))
            prepend('LIBGL_DRIVERS_PATH', os.path.join(install_dir, 'lib', 'dri'))
            prepend('LIBRARY_PATH', os.path.join(install_dir, 'lib'))
            prepend('PATH', os.path.join(install_dir, 'bin'))
            prepend('PKG_CONFIG_PATH', os.path.join(install_dir, 'share', 'pkgconfig'))
            prepend('PKG_CONFIG_PATH', os.path.join(install_dir, 'lib', 'pkgconfig'))
        return env

    @property
    def binstcmds(self):
        if self.__binstcmds is None:
            print "Don't know how to build platform {0}".format(self.__name)
            exit(1)
        return self.__binstcmds

ALL_PLATFORMS = {
    'drm': Platform(name = 'drm', parents = [], binstcmds = ['build-drm', 'install-drm']),
    'glean-mesa': Platform(name = 'glean-mesa', parents = ['glean-mesa', 'proto', 'drm'], binstcmds = ['build-glean']),
    'llvm-2.9': Platform(name = 'llvm-2.9', parents = [], binstcmds = ['build-llvm', 'install-llvm']),
    'mesa': Platform(name = 'mesa',
                     parents = ['proto', 'drm'],
                     binstcmds = ['build-mesa', 'check-mesa', 'install-mesa']),
    'mesa-32': Platform(name = 'mesa-32',
                        parents = ['proto', 'drm'],
                        binstcmds = ['build-mesa', 'check-mesa', 'install-mesa']),
    'mesa-gallium': Platform(name = 'mesa-gallium',
                             parents = ['proto', 'llvm-2.9', 'drm'],
                             binstcmds = ['build-mesa', 'check-mesa', 'install-mesa']),
    'piglit-gallium': Platform(name = 'piglit-gallium',
                               parents = ['piglit-gallium', 'mesa-gallium', 'proto', 'llvm-2.9', 'drm'],
                               binstcmds = ['build-piglit', 'install-piglit']),
    'piglit-mesa': Platform(name = 'piglit-mesa',
                            parents = ['piglit-mesa', 'mesa', 'proto', 'drm'],
                            binstcmds = ['build-piglit', 'install-piglit']),
    'piglit-mesa-32': Platform(name = 'piglit-mesa-32',
                               parents = ['piglit-mesa-32', 'mesa-32', 'proto', 'drm'],
                               binstcmds = ['build-piglit', 'install-piglit']),
    'proto': Platform(name = 'proto', parents = [], binstcmds = ['build-proto', 'install-proto']),
}

def get_platform(platform_name):
    if platform_name in ALL_PLATFORMS:
        return ALL_PLATFORMS[platform_name]
    else:
        print 'Platform {0!r} does not exist'.format(platform_name)
        exit(1)

def get_current_platform():
    if 'PLATFORM_NAME' not in os.environ:
        print 'No platform is active.'
        exit(1)
    return get_platform(os.environ['PLATFORM_NAME'])

def check_not_active():
    if 'PLATFORM_NAME' in os.environ:
        print 'Platform {0!r} is already active'.format(os.environ['PLATFORM_NAME'])
        exit(1)

def main():
    nargs = len(sys.argv) - 1
    if nargs < 1:
        usage()

    cmd = sys.argv[1]
    if cmd == 'info':
        if nargs != 2:
            usage()
        platform_name = sys.argv[2]
        platform = get_platform(platform_name)
        print 'Platform {0}:'.format(platform_name)
        for parent in platform.parents:
            print '  Parent: {0}'.format(parent)
    elif cmd == 'use':
        if nargs != 2:
            usage()
        check_not_active()
        platform_name = sys.argv[2]
        platform = get_platform(platform_name)
        os.execve('/bin/bash', ['bash'], platform.setup_env())
    elif cmd == 'using':
        if nargs < 3:
            usage()
        check_not_active()
        platform_name = sys.argv[2]
        platform = get_platform(platform_name)
        env = platform.setup_env()
        try:
            os.execvpe(sys.argv[3], sys.argv[3:], env)
        except OSError, e:
            print e
            exit(1)
    elif cmd == 'list':
        for platform_name in sorted(ALL_PLATFORMS.keys()):
            print ALL_PLATFORMS[platform_name].desc
    elif cmd == 'checkactive':
        if nargs != 1:
            usage()
        get_current_platform()
    elif cmd == 'binst':
        if nargs == 1:
            platform = get_current_platform()
            runcmds(platform.binstcmds, os.environ)
        elif nargs == 2:
            check_not_active()
            platform_name = sys.argv[2]
            platform = get_platform(platform_name)
            runcmds(platform.binstcmds, platform.setup_env())
        else:
            usage()
    else:
        usage()

if __name__ == '__main__':
    main()
